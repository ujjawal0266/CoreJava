This is a classic "Senior Java Developer" interview question, and it touches on the absolute heart of Object-Oriented Programming (OOP).
You are asking about Polymorphism and the principle of "Programming to an Interface, not an Implementation."
Here is the Deep Dive into why Map<K,V> map = new HashMap<>(); is better than HashMap<K,V> map = new HashMap<>();.

The What
The ELI5 Analogy: Imagin/e you are building a house and installing a power outlet (socket) on the wall.
The Interface (Map): The standard 3-pin socket shape.
The Implementation (HashMap): A specific appliance, like a Heater.

The Flexibility: Because you installed a standard socket (Interface), you can plug in a Heater (HashMap) today. But if it gets hot and you want a Fan (TreeMap) tomorrow, you just unplug the Heater and plug in the Fan. You do not have to tear down the wall to change the wiring.
Technical Definition: Using the parent interface (Map) as the reference type allows your code to treat different implementations (HashMap, TreeMap, LinkedHashMap) uniformly. This is Upcasting.

The Why
The History/Problem: In the early days of programming, we wrote code tightly coupled to specific types. If you wrote a method public void printUsers(HashMap<String, String> users), that method is now married to HashMap.
If your requirements changed later—say, you needed the users sorted alphabetically (which TreeMap does)—you would have to go back and rewrite every single method that expected a HashMap to now accept a TreeMap. This caused massive code refactoring headaches.

The How
Internal Mechanics: When you write Map<K,V> map, you are telling the compiler: "I promise I will only call methods that exist in the standard Map contract (like put, get, size)."
Because HashMap, TreeMap, and LinkedHashMap all sign this contract (implement the interface), the compiler doesn't care which one is actually running underneath.
Contrast in Code:

Scenario A: The "Rigid" Way (Bad)

Java

// Reference is the Child (Implementation)
HashMap<String, Integer> scores = new HashMap<>();

// Later, you pass this to a method
public void processScores(HashMap<String, Integer> data) {
    // This method ONLY works with HashMap.
    // If you pass a TreeMap here, code breaks!
}
Scenario B: The "Flexible" Way (Good)

Java

// Reference is the Parent (Interface)
Map<String, Integer> scores = new HashMap<>();

// Later, if you need sorting, you just change ONE word:
// Map<String, Integer> scores = new TreeMap<>(); // <--- Easy switch!

// The method accepts the Interface
public void processScores(Map<String, Integer> data) {
    // This method works with HashMap, TreeMap, LinkedHashMap...
    // It doesn't care, as long as it behaves like a Map.
}
The When
Concrete Use Cases:

API Design: When you are writing a library or utility method. Always accept List or Map as parameters, never ArrayList or HashMap. This lets users of your library pass whatever collection they want.

Performance Tuning: You might start with HashMap. Later, you realize you need to preserve insertion order. If you used Map references everywhere, you simply change new HashMap() to new LinkedHashMap() in one place, and the whole application updates instantly.

Unit Testing: In testing, you might want to pass a "Fake Map" or a simple stub. If your code expects the interface Map, passing a fake is easy.

The Utility
Key Benefits:

Decoupling: Your code relies on what the object does (Interface), not how it does it (Implementation).

Maintainability: Changing underlying data structures requires minimal code changes.

Interoperability: Your methods become compatible with any future implementation of Map that Java might release in JDK 25 or later.

One Exception (The "Gotcha")
You only use the Child reference (TreeMap ref = new TreeMap()) if you need a method that is specific to that child and not in the parent interface.

Example: TreeMap has methods like firstKey() or pollLastEntry(). These do not exist in the standard Map interface. If you need those specific features, you must use the TreeMap reference (or cast it).

Next Step